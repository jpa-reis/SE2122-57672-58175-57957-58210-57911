[DESIGN PATTERNS - JOÃO PEDRO ARAÚJO DOS REIS 58175]

[1 - "xmp" directory, file "DublinCoreExtractor.java"] FACADE Design Pattern
The facade design patterns takes functionality from (generally) many classes and presents it in a simple, encapsulated way. We can see this presented in this class, for starters,
just by looking and the imports. The class imports other classes for use in it's methods that are higher logically than the classes it imports. 

Example: 
private void extractYearAndMonth() {
        List<String> dates = dcSchema.getUnqualifiedSequenceValueList("date");
        if ((dates != null) && !dates.isEmpty()) {
            String date = dates.get(0).trim();
            Calendar calender = null;
            try {
                calender = DateConverter.toCalendar(date);
            } catch (IOException ignored) {
                // Ignored
            }
            if (calender != null) {
                bibEntry.setField(StandardField.YEAR, String.valueOf(calender.get(Calendar.YEAR)));
                int monthNumber = calender.get(Calendar.MONTH) + 1;
                // not the 1st of January
                if (!((monthNumber == 1) && (calender.get(Calendar.DAY_OF_MONTH) == 1))) {
                    Month.getMonthByNumber(monthNumber)
                         .ifPresent(month -> bibEntry.setMonth(month));
                }
            }
        }
    }

In this method for example we see the use of Calendar and it's constants to extract the year and month for example but the calendar is a lower level implementation in the overall logic. 

[2- "net" directory, file "ProxyAuthenticator.java"] PROXY Design Pattern

In this case this design pattern uses user authentication methods and controls registers serving as the intermediary between the system and the program. 
We can this happening in the following example: 

 if (getRequestorType() == RequestorType.PROXY) {
            String prot = getRequestingProtocol().toLowerCase(Locale.ROOT);
            String host = System.getProperty(prot + ".proxyHost", "");
            String port = System.getProperty(prot + ".proxyPort", "80");
            String user = System.getProperty(prot + ".proxyUser", "");
            String password = System.getProperty(prot + ".proxyPassword", "");
            if (getRequestingHost().equalsIgnoreCase(host) && (Integer.parseInt(port) == getRequestingPort())) {
                return new PasswordAuthentication(user, password.toCharArray());
            }
        }
This quests uses the proxy instead of calling the System directly, this allows the app not to worry about the specifics of the authentication. 

[3- "util" directory, files "FileType.java", "StandardFileType.java", "UnknownFileType.java"]Template method Design Pattern 

We can find this design pattern here as the method getExtensionsWithDot() uses another (not implemented) method called getExtensions in the interface. This method represents 
a step to output the result getExtensionsWithDot() and has different implementations in the implemented classes. Even though both methods are the same, the values of the variable 
they return aren´t calculated in the same way.  The constructor of each class assigns values in a different way to the returned variable.

***FileType.java example***

default List<String> getExtensionsWithDot() {
        return getExtensions().stream()
                              .map(extension -> "*." + extension)
                              .collect(Collectors.toList());
    }

    List<String> getExtensions();

***StandardFileType.java example***

	this.extensions = Arrays.asList(extensions);

***UnknownFileType.java example***

	for (int i = 0; i < extensions.length; i++) {
            if (extensions[i].contains(".")) {
                extensions[i] = extensions[i].substring(extensions[i].indexOf('.') + 1);
            }
            extensions[i] = extensions[i].toLowerCase(Locale.ROOT);
        }
        this.extensions = Arrays.asList(extensions);

//BOTH CLASSES
public List<String> getExtensions(){ 
	return extensions;
]