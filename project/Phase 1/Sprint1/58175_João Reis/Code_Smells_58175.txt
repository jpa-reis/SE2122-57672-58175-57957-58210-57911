[CODE SMELLS - JOÃO PEDRO ARAÚJO DOS REIS 58175]

[1 - l10n/localizationLocator.java] Unused parameter and returns information used in another class.

Class:
public class LocalizationLocator implements ResourceLocator {
    @Override
    public ResourceBundle getResourceBundle(String s) {
        return Localization.getMessages();
    }
}

Why it's a code smell:
This class has only one method (getResourceBundle(String s)) with a parameter that goes unused. 
Besides that, the body of the method returns information storned in another class making the class
seemingly pointless. 

What can be done to fix it: 
I think the intent of this class was attribute a meaning in the context of the problem behind a class 
which is unecessary as it only enlarges de amount of classes the src code already has. The parameter should
be removed. 

[2 -  layout/AbstractParamLayoutFormatter.java] If statements make the method too complex.

Code example:
if ((arg.charAt(i) == AbstractParamLayoutFormatter.SEPARATOR) && !escaped) {
                parts.add(current.toString());
                current = new StringBuilder();
} else if (arg.charAt(i) == '\\') {
                if (escaped) {
                    escaped = false;
                    current.append(arg.charAt(i));
                } else {
                    escaped = true;
                } 

Why it's a code smell: This class has only one method. It has a great deal of sucsession of if/else conditions
which make the method unecessarily complex. 

What can be done to fix it: To fix this method's complexity auxiliary functions could be made to encapsulate 
if/else functionality and make more apperanrent the condition's purpose.

[3 - layout/LayoutHelper] Methods are too big.

Code example: 
private void parseField() throws IOException {
        int c;
        StringBuilder buffer = null;
        String name;

        while (!endOfFile) {
            c = read();
            if (c == -1) {
                endOfFile = true;
            }

            if (!Character.isLetter((char) c) && (c != '_')) {
                unread(c);

                name = buffer == null ? "" : buffer.toString();

                if (name.isEmpty()) {
                    StringBuilder lastFive = new StringBuilder(10);
                    if (parsedEntries.isEmpty()) {
                        lastFive.append("unknown");
                    } else {
                        for (StringInt entry : parsedEntries.subList(Math.max(0, parsedEntries.size() - 6),
                                parsedEntries.size() - 1)) {
                            lastFive.append(entry.s);
                        }
                    }
                    throw new IOException(
                            "Backslash parsing error near \'" + lastFive.toString().replace("\n", " ") + '\'');
                }

                if ("begin".equalsIgnoreCase(name)) {
                    // get field name
                    doBracketedField(LayoutHelper.IS_FIELD_START);

                    return;
                } else if ("begingroup".equalsIgnoreCase(name)) {
                    // get field name
                    doBracketedField(LayoutHelper.IS_GROUP_START);
                    return;
                } else if ("format".equalsIgnoreCase(name)) {
                    if (c == '[') {
                        // get format parameter
                        // get field name
                        doBracketedOptionField();

                        return;
                    } else {
                        // get field name
                        doBracketedField(LayoutHelper.IS_OPTION_FIELD);

                        return;
                    }
                } else if ("filename".equalsIgnoreCase(name)) {
                    // Print the name of the database BIB file.
                    // This is only supported in begin/end layouts, not in
                    // entry layouts.
                    parsedEntries.add(new StringInt(name, LayoutHelper.IS_FILENAME));
                    return;
                } else if ("filepath".equalsIgnoreCase(name)) {
                    // Print the full path of the database BIB file.
                    // This is only supported in begin/end layouts, not in
                    // entry layouts.
                    parsedEntries.add(new StringInt(name, LayoutHelper.IS_FILEPATH));
                    return;
                } else if ("end".equalsIgnoreCase(name)) {
                    // get field name
                    doBracketedField(LayoutHelper.IS_FIELD_END);
                    return;
                } else if ("endgroup".equalsIgnoreCase(name)) {
                    // get field name
                    doBracketedField(LayoutHelper.IS_GROUP_END);
                    return;
                } else if ("encoding".equalsIgnoreCase(name)) {
                    // Print the name of the current encoding used for export.
                    // This is only supported in begin/end layouts, not in
                    // entry layouts.
                    parsedEntries.add(new StringInt(name, LayoutHelper.IS_ENCODING_NAME));
                    return;
                }

                // for all other cases -> simple command
                parsedEntries.add(new StringInt(name, LayoutHelper.IS_SIMPLE_COMMAND));

                return;
            } else {
                if (buffer == null) {
                    buffer = new StringBuilder(100);
                }

                buffer.append((char) c);
            }
        }
    }

Why it's a code smell: This method suffers from the same problem as the previous code smell, however, 
this one can better ilustrate a reccuring problem seen in the code. Methods too big, this method alone is nearly
100 lines long and should be reduced into different functions as it is very difficult to understand 
it's purpose. I would also like to say that it doesn't have anu comment for a method that is this size. 

What can be done to fix it: To fix this code smell the subproblems should be divided into different private 
functions and commented. 